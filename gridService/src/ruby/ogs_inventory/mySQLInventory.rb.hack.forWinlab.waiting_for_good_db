# This is "mySQLInventory.rb".

# This file is in dire need of an accurate copyright notice.

# This implements the MySQLInventory class, instances of which
# represent query engines over the MySQL inventory database.  Some
# specific queries have methods here.

# you may need to require "mobject" first?
# (uncomment if no MySQL module in this ruby version)
require 'util/mysql.rb'
require 'set'

class MySQLInventory < MObject

  def initialize(host, user, password, database)
    @my   = nil
    @host  = host
    @user  = user
    @pw    = password
    @db    =  database
    open()
    #@host  = "internal1.orbit-lab.org"
    #@user  = "orbit"
    #@pw    = "orbit"
    #@db    = "inventory"
  end

  # open a connection to the MySQL Server given in initialize()
  #
  def open()
    begin
      @my = Mysql.connect(@host, @user, @pw, @db)
    rescue MysqlError => e
      p "SQL error message: #{e.error}."
    end	
  end

  # close a connection once gained from open()
  #
  def close() 
    @my.close();
  end

  # This method queries the MySQL Server for all the nodes having
  # an inteface belonging to a given tag 
  #
  def getNodeCoordinateRange(domain = "grid")
    result = Array.new
    qs = <<END_QS1
SELECT x_max, y_max, z_max
  FROM testbeds
WHERE node_domain = '#{domain}'
END_QS1
    begin
      @my.query(qs).each() { | x,y,z | 
           result.push(x) 
           result.push(y) 
           result.push(z) 
      }
    rescue MysqlError => e
      err_str = "Inventory - Could not execute query in getNodeCoordinateRange for T:#{domain}"
      p err_str
      MObject.debug err_str
    end
    result
  end

  ## XXX These getFoo() methods should really be condensed into
  ## something so that there isn't all this code repetition.

  # Query the database for the database id of the motherboard at x/y/domain.
  # This is used for generating other more interesting queries.
  #
  def getMotherboardID(x, y, domain = "grid") 
    motherboardID = nil
    qs = "SELECT nodes.motherboard_id " \
         "FROM testbeds " \
           "LEFT JOIN locations ON testbeds.id = locations.testbed_id " \
           "LEFT JOIN nodes ON locations.id = nodes.location_id " \
	 "WHERE testbeds.node_domain = '#{domain}' " \
           "AND locations.x = #{x} " \
           "AND locations.y = #{y} "
    begin
      results=@my.query(qs)
      if results.each() { |mid| 
          motherboardID = mid
        }
      end
    rescue MysqlError => e
      p "Inventory - Could not get Motherboard ID for T:#{domain} - X:#{x} - Y:#{y}"
      MObject.debug "Inventory - Could not get Motherboard ID for T:#{domain} - X:#{x} - Y:#{y}"
    end
    motherboardID
  end

  # Query the MySQL Server for the MAC address corresponding to a
  # given interface name on a given node.
  #
  def getMacAddrByName(x, y, cname = "ath0", domain = "grid") 
    addr = nil
    # First, find out the Motherboard ID of the requested node
    # XXX could start a transaction here?
    #moid = getMotherboardID(x, y, domain)
    # Second, find out the MAC address of the required interface on that Motherboard
    #qs = "SELECT interfaces.mac " \
    #     "FROM interfaces " \
    #       "LEFT JOIN motherboards ON interfaces.motherboard_id = motherboards.id " \
    #    "WHERE motherboards.id= #{moid} " \
    #    "AND canonical_name = '#{cname}' "

    # Thierry - 
    # I had to put together a demo that needed info from the inventory, 
    # I fixed this so it works again with the inventory as of 21/08/08
    # ToDo: if inventory is not changing anymore, we should 'clean' this method a bit :)
    qs = <<TEMPFIX_Q
SELECT devices.mac 
  FROM devices 
  LEFT JOIN nodes ON devices.motherboard_id = nodes.motherboard_id 
  LEFT JOIN locations ON nodes.location_id = locations.id 
  LEFT JOIN testbeds ON locations.testbed_id = testbeds.id
WHERE testbeds.node_domain='#{domain}' 
  AND locations.x=#{x} 
  AND locations.y=#{y} 
  AND canonical_name='#{cname}';
TEMPFIX_Q

    begin
      results=@my.query(qs)
      if results.each() { |mac| 
          addr = mac
          MObject.debug " Inventory - T:#{domain} - X:#{x} - Y:#{y} - CNAME:#{cname} - MAC:#{addr}"
        }
      end
    rescue MysqlError => e
      p "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y} - CNAME:#{cname}"
      MObject.debug "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y} - CNAME:#{cname}"
      MObject.debug " Inventory - QS: #{qs}" 
    end
    addr
  end
	
  def getMacAddrByType(x, y, type = 1, domain = "grid")
    # This method should be considered deprecated because it exposes
    # device_id numbers to higher levels of abstraction.  device_id
    # numbers are not a "type", but rather a means of associating rows
    # in two tables in the database.  It is probably a better idea to
    # only expose PCI ID numbers.  See getMacAddrByOUI().
    p "Warning - getMacAddrByType() probably isn't what you want.  See getMacAddrByOUI()."
    MObject.warn "Inventory - getMacAddrByType() is deprecated."
    cards = []    
    # First, find out the Motherboard ID of the requested node
    moid = getMotherboardID(x, y, domain)
    # Second, find out the MAC address of the interfaces with the required type on that Motherboard
    qs = "SELECT interfaces.mac interfaces.device_id " \
         "FROM interfaces " \
           "LEFT JOIN motherboards ON interfaces.motherboard_id = motherboards.id " \
	 "WHERE motherboards.id= #{moid} " \
	   "AND device_id = #{type} "
    begin
      results=@my.query(qs)
      if results.each() { |mac, did| 
          p "  Got for ["+x.to_s+","+y.to_s+"] type="+type+" mac=["+mac+"]"
          cards |= mac         
          MObject.debug " Inventory - T:#{domain} - X:#{x} - Y:#{y} - MAC:#{mac} - TYPE:#{did}" 
        }
      end
    rescue MysqlError => e
      p "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y} - TYPE:#{type}"
      MObject.debug "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y} - TYPE:#{type}"
    end
    cards
  end

  def getMacAddrByOUI(x, y, oui, domain = "grid")
    cards = []
    # XXX should start transaction here?
    moid = getMotherboardID(x, y, domain)
    qs = "SELECT interfaces.mac " \
         "FROM interfaces " \
           "LEFT JOIN motherboards ON interfaces.motherboard_id = motherboards.id " \
           "LEFT JOIN devices ON interfaces.device_id = devices.id " \
         "WHERE motherboards.id = #{moid} " \
           "AND devices.oui = #{oui} "
    begin
      results = @my.query(qs)
      if results.each() { | mac |
          cards |= mac
          MObject.debug " Inventory - T:#{domain} - X:#{x} - Y:#{y} - MAC:#{mac} - OUI:#{oui}" 
        }
      end
    rescue MysqlError => e
      p "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y} - OUI:#{oui}"
      MObject.debug "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y} - OUI:#{oui}"
    end
    cards
  end

  # This method queries the MySQL Server for all the MAC addresses
  # corresponding to a given node
  #
  def getAllMacAddr(x, y, domain = "grid")
    addr = Set.new
    # First, find out the Motherboard ID of the requested node
    moid = getMotherboardID(x, y, domain)
    # Second, find out the MAC address of all the interfaces on that Motherboard
    qs = "SELECT interfaces.mac, interfaces.canonical_name, devices.oui " \
         "FROM interfaces " \
           "LEFT JOIN motherboards ON interfaces.motherboard_id = motherboards.id " \
           "LEFT JOIN devices ON interfaces.device_id = devices.id " \
         "WHERE motherboards.id = #{moid} "
    begin
      results=@my.query(qs)
      if results.each() { |mac, cnm, oui| 
          couple = [cnm, mac]
          addr.add(couple)
          MObject.debug " Inventory - T:#{domain} - X:#{x} - Y:#{y} - CNAME:#{cnm} - MAC:#{mac} - OUI:#{oui}" 
        }
      end
    rescue MysqlError => e
      p "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y}"
      MObject.debug "Inventory - Could not get MAC for T:#{domain} - X:#{x} - Y:#{y}"
    end
    addr
  end

  def getAllPCIID(x, y, domain = "grid")
    result = Set.new
    motherboard_id = getMotherboardID(x, y, domain)
    querry_string = <<TeH_KWIRRY
SELECT devices.canonical_name, device_kinds.vendor, device_kinds.device
  FROM devices
  LEFT JOIN motherboards ON devices.motherboard_id = motherboards.id
  LEFT JOIN device_kinds ON devices.device_kind_id = device_kinds.id
  WHERE motherboards.id = #{motherboard_id}
TeH_KWIRRY
    begin
      @my.query(querry_string).each() { | cn, v, d | result.add([cn, v, d]) }
    rescue MysqlError => e
      err_str = "Inventory - Could not execute query in getAllPCIID; T:#{domain} - X:#{x} - Y:#{y}"
      p err_str
      MObject.debug err_str
    end
    result
  end

  # This method queries the MySQL Server for all the nodes having
  # an inteface with a given OUI 
  #
  def getNodesWithOUIInterfaces(oui, domain = "grid")
    result = Array.new
    exists = Hash.new
    qs = <<END_QS
SELECT locations.x, locations.y
  FROM testbeds
  LEFT JOIN locations ON locations.testbed_id = testbeds.id
  LEFT JOIN nodes ON locations.id = nodes.location_id
  LEFT JOIN devices ON devices.motherboard_id = nodes.motherboard_id
  LEFT JOIN device_kinds ON device_kinds.id = devices.device_kind_id
  LEFT JOIN device_ouis ON device_ouis.device_kind_id = device_kinds.id
  WHERE device_ouis.oui = '#{oui}' 
    AND testbeds.node_domain = '#{domain}'
  ORDER BY locations.x, locations.y
END_QS
    begin
      @my.query(qs).each() { | x, y | 
          if (exists["#{x},#{y}"] == nil) 
            exists["#{x},#{y}"] = "A"
           result.push([x,y]) 
          end
    }
    rescue MysqlError => e
      err_str = "Inventory - Could not execute query in getNodesWithOIUInterfaces; OUI:#{oui}, T:#{domain}"
      p err_str
      MObject.debug err_str
    end
    result
  end

  # This method queries the MySQL Server for all the aliases (tags) defined
  # in the tag table
  #
  def getDeviceAliases()
    result = Array.new
    qs = <<END_QS1
SELECT DISTINCT tag
FROM `device_tags` 
END_QS1
    begin
      @my.query(qs).each() { | t | 
           result.push(t) 
      }
    rescue MysqlError => e
      err_str = "Inventory - Could not execute query in getDeviceAliases"
      p err_str
      MObject.debug err_str
    end
    MObject.debug ("Got result")
    result
  end



  # This method queries the MySQL Server for all the nodes having
  # an inteface belonging to a given tag 
  #
  def getNodesWithTagInterfaces(tag, domain = "grid")
    result = Array.new
    qs = <<END_QS2
SELECT DISTINCT locations.x, locations.y
  FROM testbeds
  LEFT JOIN locations ON locations.testbed_id = testbeds.id
  LEFT JOIN nodes ON locations.id = nodes.location_id
  LEFT JOIN devices ON devices.motherboard_id = nodes.motherboard_id
  LEFT JOIN device_kinds ON device_kinds.id = devices.device_kind_id
  LEFT JOIN device_tags ON device_tags.device_kind_id = device_kinds.id
WHERE device_tags.tag = '#{tag}'
  AND testbeds.node_domain = '#{domain}'
ORDER BY locations.x, locations.y
END_QS2
    begin
      @my.query(qs).each() { | x, y | 
           result.push([x,y]) 
    }
    rescue MysqlError => e
      err_str = "Inventory - Could not execute query in getNodesWithOIUInterfaces; OUI:#{oui}, T:#{domain}"
      p err_str
      MObject.debug err_str
    end
    result
  end


  #
  # HACK
  # In the SVN code this is replaced by a proper SQL query to the inventory DATABASE
  # Here we leave this HACK until the Winlab Inventory is up-to-date
  #
  def getConfigByKey(key, domain = "grid") 
    value = nil
    case key
      when "pxe_url" 
        value = 'http://pxe:5022/pxe'
      when "cmc_url" 
        value = "http://cmc:5012/cmc"
      when "oml_url" 
        value = "http://cmc:5022/oml2"
	# TODO
	# FIXME
	# When all tested ok, put OML2 server and GS on the 'oml' machine!
        #value = "http://oml:5022/oml"
      when "oml_port" 
        value = 5022
      when "oml_host" 
        value = "oml"
      when "oml_localhost" 
        value = case
	  when domain == 'grid' : '10.10.0.10'
	  when domain == 'sb1'  : '10.11.0.10'
	  when domain == 'sb2'  : '10.12.0.10'
	  when domain == 'sb5'  : '10.15.0.10'
	  when domain == 'sb6'  : '10.16.0.10'
	  when domain == 'sb7'  : '10.17.0.10'
	  when domain == 'sb8'  : '10.18.0.10'
	end
      when "frisbee_url" 
        value = 'http://frisbee:5022/frisbee'
      when "frisbee_default_disk" 
        value = '/dev/hda'
      when "x_max" 
        value = case
	  when domain == 'grid' : 20
	  when domain == 'sb1'  : 1
	  when domain == 'sb2'  : 1
	  when domain == 'sb5'  : 1
	  when domain == 'sb6'  : 1
	  when domain == 'sb7'  : 1
	  when domain == 'sb8'  : 1
	end
      when "y_max" 
        value = case
	  when domain == 'grid' : 20
	  when domain == 'sb1'  : 2
	  when domain == 'sb2'  : 2
	  when domain == 'sb5'  : 2
	  when domain == 'sb6'  : 2
	  when domain == 'sb7'  : 2
	  when domain == 'sb8'  : 2
	end
    end
    MObject.debug " Inventory - Config - key: #{key} - value: #{value}"
    return value
  end

  #
  # HACK
  # In the SVN code this is replaced by a proper SQL query to the inventory DATABASE
  # Here we leave this HACK until the Winlab Inventory is up-to-date
  #
  def getControlIP(x, y, domain = "grid") 
    addr = nil
    case domain
      when "grid"
        addr = "10.10.#{x}.#{y}"
      when "sb1"
        addr = "10.11.#{x}.#{y}"
      when "sb2"
        addr = "10.12.#{x}.#{y}"
      when "sb5"
        addr = "10.15.#{x}.#{y}"
      when "sb6"
        addr = "10.16.#{x}.#{y}"
      when "sb7"
        addr = "10.17.#{x}.#{y}"
      when "sb8"
        addr = "10.18.#{x}.#{y}"
    end
    MObject.debug " Inventory - T:#{domain} - X:#{x} - Y:#{y} - Control IP:#{addr}"
    return addr
  end

end

