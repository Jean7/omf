#!/usr/bin/env ruby

require "optparse"
require 'omf_common'
$stdout.sync = true

options = {
  dsl: 'xmpp_blather',
  pubsub_host: 'pubsub',
  node: 'interlagos'
}

executable_name = File.basename($PROGRAM_NAME)

option_parser = OptionParser.new do |opts|
  opts.banner = "usage: #{executable_name} [options]"

  opts.on("-u USER", "Username") do |user|
    options[:user] = user
  end

  opts.on("-p PASSWORD", "Password") do |password|
    options[:password] = password
  end

  opts.on("-s SERVER", "XMPP server") do |server|
    options[:server] = server
  end

  opts.on("-d", "--debug", "Debug mode") do
    options[:debug] = true
  end
end

begin
  option_parser.parse!
rescue => e
  puts e.message
  puts ""
  puts option_parser.help
  exit(1)
end

unless options[:server] && options[:user] && options[:server]
  puts option_parser.help
  exit(1)
end

Blather.logger = logger
Blather.logger.level = Logger::DEBUG if options[:debug]

comm = OmfCommon::Comm.new(options[:dsl])
host = nil

create_a_mock = OmfCommon::Message.create { |v| v.property('type', 'mock') }.sign

comm.when_ready do
  logger.info "CONNECTED: #{comm.jid.inspect}"
  host = "#{options[:pubsub_host]}.#{comm.jid.domain}"

  EM.add_periodic_timer(1) do
    comm.subscribe(options[:node], host) do
      comm.publish(options[:node], create_a_mock, host)
    end
  end
end

comm.node_event :items, :node do |e|
  e.items.each do |item|
    m = OmfCommon::Message.parse(item.payload)
    logger.error "Invalid Message\n#{m.to_xml}" unless m.valid?
    context_id = m.read_element("//context_id").first.content
    #logger.info "RECEIVED: #{m.operation.to_s} <Context ID> #{context_id}"

    begin
      case m.operation
      when :inform
        inform_type = m.read_element("//inform_type").first.content
        case inform_type
        when 'CREATED'
          resource_id = m.read_element("//resource_id").first.content
          logger.info "Resource #{resource_id} CREATED"
          comm.subscribe(resource_id, host)
        end
      end
    rescue => e
      logger.error "#{e.message}\n#{e.backtrace.join("\n")}"
    end
  end
end

# Generic pubsub event
comm.pubsub_event do |e|
  logger.debug "PUBSUB GENERIC EVENT: #{e}"
end

trap(:INT) { comm.disconnect(host) }
trap(:TERM) { comm.disconnect(host) }

EM.run { comm.connect(options[:user], options[:password], options[:server]) }
