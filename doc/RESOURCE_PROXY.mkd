# Implement your own resource proxy

## Before we could start

Install a XMPP server. [Installation notes for Openfire](https://omf.mytestbed.net/projects/omf/wiki/Installation_Guide_54#Configuring-XMPP)

Create two users in the XMPP server, one for resource controller side, one for client side. *This step is required because of the lack of in-band registration support (XEP-0077) in the XMPP library, we will add the support in the final release.*

For this tutorial, we created two users: alpha and bravo, with both passwords set to 'pw'

Now we need to nstall omf\_rc pre-release gems

    gem install omf_rc --pre

## Scenario

Suppose we are managing a formula 1 team's garage, and we want to test the engines' we have, simply by adjusting the throttle and observing the engines' RPM. Unless you had the opportunity to connect your laptop to a real formula 1 engine, we can assume that all we need here is a mock up engine written in ruby.

## Coding

### Resource controller script skeleton (server side)

Firstly, we need a resource controller script runs on the server side, which contains an instance of resource proxy represents 'garage', we can then use resource factory method to create such

    OmfRc::ResourceFactory.new(:garage, options)

This does following behind the scene

* Extend the instance with resource proxy module named 'garage' (_should be defined first_).
* If additional options provided for pubsub communicator, a communicator instance will be created and attached to this resource proxy instance.
* If before\_ready hook provided in the module, they will be executed.

Refer to [OmfRc::ResourceFactory](../../OmfRc/ResourceFactory) for implementation.

We start by this skeleton, save it as garage\_controller.rb

    #!/usr/bin/env ruby

    require 'omf_rc'
    require 'omf_rc/resource_factory'
    $stdout.sync = true

    options = {
      user: 'alpha',
      password: 'pw',
      server: 'localhost', # XMPP server domain
      uid: 'mclaren', # Id of the garage (resource)
    }

    EM.run do
      # Use resource factory method to initialise a new instance of garage
      garage = OmfRc::ResourceFactory.new(:garage, options)
      # Let garage connect to XMPP server
      garage.connect

      # Disconnect garage from XMPP server, when these two signals received
      trap(:INT) { garage.disconnect }
      trap(:TERM) { garage.disconnect }
    end

Now try the script.

### Resource proxy mixin module definition

The above script will fail to start, complaining that resource proxy of type 'garage' couldn't be found in the resource factory. Thus we need to define it, register it, just before the main event machine loop (before the line 'EM.run do')

    module OmfRc::ResourceProxy::Garage
      include OmfRc::ResourceProxyDSL

      register_proxy :garage
    end

Run the script again, it should prompt user alpha got connected.

We also need definition for engines, since their instances will be created later (via 'create' messages published by the client script, through XMPP).

    module OmfRc::ResourceProxy::Engine
      include OmfRc::ResourceProxyDSL

      register_proxy :engine
    end

A resource proxy mixin module represents the functionalities the resource could provide, for example, this engine proxy can provide adjustable throttle to be configured, RPM value to be requested, etc.. The features defined here will be available to the engine proxy instance by the time it is created by ResourceFactory.

### Add more features to engine

Now we are going to add some features by including the following inside the engine proxy module:

    # before_ready hook will be called during the initialisation of the resource instance
    #
    register_hook :before_ready do |resource|
      resource.metadata.max_power ||= 676 # Set the engine maximum power to 676 bhp
      resource.metadata.provider ||= 'Honda' # Engine provider defaults to Honda
      resource.metadata.max_rpm ||= 12500 # Maximum RPM of the engine is 12,500
      resource.metadata.rpm ||= 1000 # After engine starts, RPM will stay at 1000 (i.e. engine is idle)
      resource.metadata.throttle ||= 0.0 # Throttle is 0% initially

      # The following simulates the engine RPM, it basically says:
      # * Applying 100% throttle will increase RPM by 5000 per second
      # * Engine will reduce RPM by 250 per second when no throttle applied
      # * If RPM exceed engine's maximum RPM, the engine will blow.
      #
      EM.add_periodic_timer(1) do
        unless resource.metadata.rpm == 0
          raise 'Engine blown up' if resource.metadata.rpm > resource.metadata.max_rpm
          resource.metadata.rpm += (resource.metadata.throttle * 5000 - 250)
          resource.metadata.rpm = 1000 if resource.metadata.rpm < 1000
        end
      end
    end

    # before_release hook will be called before the resource is fully released, shut down the engine in this case.
    #
    register_hook :before_release do |resource|
      # Reduce throttle to 0%
      resource.metadata.throttle = 0.0
      # Reduce RPM to 0
      resource.metadata.rpm = 0
    end

    # We want RPM to be availabe for requesting
    register_request :rpm do |resource|
      if resource.metadata.rpm > resource.metadata.max_rpm
        raise 'Engine blown up'
      else
        resource.metadata.rpm.to_i
      end
    end

    # We want some default metadata to be availabe for requesting
    %(provider max_power max_rpm).each do |attr|
      register_request attr do |resource|
        resource.metadata[attr]
      end
    end

    # We want throttle to be availabe for configuring (i.e. changing throttle)
    register_configure :throttle do |resource, value|
      resource.metadata.throttle = value.to_f / 100.0
    end

### Engine controller script (client side)

Experiment controller is not available yet, we need to use pubsub comm (communicator) from omf\_common library to interact with the XMPP system, i.e. sending out operation messages and capturing the inform messages.

    #!/usr/bin/env ruby

    require 'omf_common'
    $stdout.sync = true

    include OmfCommon

    options = {
      user: 'bravo',
      password: 'pw',
      server: 'localhost',
      uid: 'mclaren',
      pubsub_host: 'pubsub',
    }

    comm = Comm.new(:xmpp_blather)
    host = nil

    # For simplicity, use comm instance directly
    comm.when_ready do
      logger.info "CONNECTED: #{comm.jid.inspect}"
      host = "#{options[:pubsub_host]}.#{comm.jid.domain}"

      # We assume the node where RC runs started already
      comm.subscribe(options[:uid], host) do |e|
        if e.error?
          comm.disconnect(host)
        else
          comm.publish(
            options[:uid],
            Message.create { |v| v.property('type', 'engine') },
            host)
        end
      end
    end

    # Fired when messages published to the nodes I subscribed to
    comm.node_event do |e|
      e.items.each do |item|
        begin
          # Parse the message (pubsub item payload)
          message = Message.parse(item.payload)
          # We are only interested in inform messages for the moment
          if message.operation == :inform
            inform_type = message.read_content("inform_type")
            case inform_type
            when 'CREATED'
              engine_id = message.read_content("resource_id")
              logger.info "Engine #{engine_id} ready for testing"
            when 'STATUS'
              message.read_element("//property").each do |p|
                logger.info "#{p.attr('key')} => #{p.content.strip}"
              end
            when 'FAILED'
              logger.error message.read_content("error_message")
            when 'RELEASED'
              logger.warn "Engine turned off (resource released)"
            end
          end
        rescue => e
          logger.error "#{e.message}\n#{e.backtrace.join("\n")}"
        end
      end
    end

    EM.run do
      comm.connect(options[:user], options[:password], options[:server])
      trap(:INT) { comm.disconnect(host) }
      trap(:TERM) { comm.disconnect(host) }
    end

### More actions on engine controller (client side)

    comm.subscribe(engine_id, host) do
      # Engine is ready, get some information about the engine
      comm.publish(engine_id,
                   Message.request do |v|
                     v.property('max_rpm')
                     v.property('provider')
                     v.property('max_power')
                   end.sign,
                   host)

      # Checking RPM every 1 second
      EM.add_periodic_timer(1) do
        comm.publish(engine_id,
                     Message.request { |v| v.property('rpm') }.sign,
                     host)
      end

      # Apply 50% throttle
      comm.publish(engine_id,
                   Message.configure { |v| v.property('throttle', '50') }.sign,
                   host)

      # Some time we want to reduce throttle to 0, avoid blowing up the engine
      EM.add_timer(5) do
        comm.publish(engine_id,
                     Message.configure { |v| v.property('throttle', '0') }.sign,
                     host)
      end

      # 30 seconds later, we will 'release' this engine

      EM.add_timer(20) do
        comm.publish(engine_id,
                     Message.release.sign,
                     host)
      end
    end

## Include resource proxy modules as part of the default package

The default location of resource proxy definition files are located in the directory [omf\_rc/lib/omf\_rc/resource\_proxy](https://github.com/mytestbed/omf/tree/master/omf_rc/lib/omf_rc/resource_proxy).

If you would like to include these resource proxy definitions as part of default resource controller package, save them under this default directory, following this naming convention: OmfRc::ResourceProxy::Engine will register a proxy named :engine, and saved to file omf\_rc/lib/omf\_rc/resource\_proxy/engine.rb

To load these default resource proxies, simple call a load method provided by ResourceFactory class in your resource controller script (e.g. engine\_control.rb)

    OmfRc::ResourceFactory.load_default_resource_proxies

## Full DSL methods list

In the previous example, we use method register\_proxy to register resource proxy, register\_request to provide property to be requested, etc. They are all part of resource proxy DSL, and provided by included module resource_proxy_dsl.

  include OmfRc::ResourceProxyDSL

The full list of resource proxy DSL can be found here: [DSL API](../../OmfRc/ResourceProxyDSL/ClassMethods)

## Abstract class

The abstract class OmfRc::ResourceProxy::Abstract is capturing all the logics regarding resource hierarchy, communications to pubsub system and methods to create, configure, request and release resources. Please note that the actual functionality of the resources are defined in proxy modules.

[OmfRc::ResourceProxy::AbstractResource](../../OmfRc/ResourceProxy/AbstractResource)

## Resource proxy utility

To avoid overloading these modules, we can refactor some of the common features into utility modules. These modules basically provide a mapping between properties and underline system application. Take the example of iw utility module implementation here: *(Refer to DSL section for syntax details)*

    module OmfRc::Util::Iw
      include OmfRc::ResourceProxyDSL

Take the example of the new generic wifi proxy module, we want to configure some wireless related properties (iw), and to load certain drivers/modules (mod). Since we already have these utility modules defined, all we need to do is to simply include these in the wifi module.

    module OmfRc::ResourceProxy::Wifi
      include OmfRc::ResourceProxyDSL

      register_proxy :wifi

      utility :iw
    end

## Resource Proxy module


