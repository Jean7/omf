#!/usr/bin/env ruby

require "optparse"
require 'blather/client/dsl'
$stdout.sync = true

# Here is the monkey patch to blather pubsub dsl, since the default DSL doesn't support creating pubsub node with non-default config
#
module Blather
  module DSL
    class PubSub
      def create_configure(node, configure, host = nil)
        stanza = Stanza::PubSub::Create.new(:set, send_to(host), node)
        stanza.configure_node << configure
        request(stanza) { |n| yield n if block_given? }
      end
    end
  end
end

module XMPPTest
  extend Blather::DSL

  @@configure = Blather::Stanza::X.new({
    :type => :submit,
    :fields => [
      { :var => "FORM_TYPE", :type => 'hidden', :value => "http://jabber.org/protocol/pubsub#node_config" },
      { :var => "pubsub#title", :value => "/blather" },
      { :var => "pubsub#persist_items", :value => "1" },
      { :var => "pubsub#max_items", :value => "1" },
      { :var => "pubsub#notify_retract",  :value => "0" },
      { :var => "pubsub#publish_model", :value => "open" }]
  })

  def self.run
    client.run
  end

  def self.setup(username, password, domain, debug)
    Blather.logger.level = Logger::DEBUG if debug
    jid = "#{username}@#{domain}"
    @@pubsub = "pubsub.#{domain}"
    @@subid = nil
    client.setup jid, password
  end

  def self.disconnect
    if @@subid
      pubsub.unsubscribe('/blather', nil, @@subid, @@pubsub) do |m|
        puts "Unsubscribe > Topic /blather unsubscribed"

        pubsub.delete('/blather', @@pubsub) do |m|
          puts "Delete > Topic /blather deleted"
          puts "Disconnecting ..."
          client.close
        end
      end
    else
      client.close
    end
  end

  when_ready do
    puts "Ready > Connected"

    discover :items, @@pubsub, '' do |response|
      if response.items.size > 0
        puts "Discover > There are #{response.items.size} topics"
        puts "Discover > First topic on list: #{response.items.first.node}"
      end
    end

    pubsub.create_configure('/blather', @@configure, @@pubsub) do |m|
      puts "Create > Topic should have been created"
      discover :items, @@pubsub, '' do |response|
        if response.items.find { |v| v.node == '/blather' }
          puts "Discover > Found the topic /blather we just created"
          pubsub.subscribe('/blather', nil, @@pubsub) do |m|
            @@subid = m.subid
            puts "Subscribe > Subscribed with id #{@@subid}" if @@subid

            EM::add_periodic_timer(2) do
              pubsub.publish('/blather', Blather::Stanza::Message.new(nil, "Hello World #{rand(100)}"), @@pubsub)
            end
          end
        end
      end
    end

    pubsub_event :items do |m|
      puts "Event > Pubsub Item received"
      puts m.subscription
      m.items.each do |i|
        puts i.payload_node.class
        puts "Message > #{i.payload_node.child.content}"
      end
    end
  end
end

# Define Banner and Options
@username = @password = @server = @remote = @topic = @debug = nil
@opts = OptionParser.new
@opts.banner = "\nTest XMPP Peering\n\n"+
  "Usage: #{$0} [OPTIONS]\n\n"
@opts.on("-u", "--username NAME",
         "Username to login to home server") {|n| @username = n }
@opts.on("-p", "--password PASS",
         "Password to login to home server") {|n| @password = n }
@opts.on("-s", "--server HOST",
         "Hostname for home server") {|n| @server = n }
@opts.on("-r", "--remote HOST",
         "Hostname for remote server (default= home server") { |n| @remote = n }
@opts.on("-d", "--debug",
         "Debug mode") {|n| @debug = true }
@opts.on("-t", "--topic TOPIC",
         "Topic name to use for test (optional)") {|n| @topic = n }

def show_help() puts @opts ; puts "\n" ; exit;  end

@opts.parse(ARGV)

show_help if !@username || !@password || !@server
@remote = @server if @remote.nil?

trap(:INT) { XMPPTest.disconnect }
trap(:TERM) { XMPPTest.disconnect }

EM.run {
  XMPPTest.setup(@username, @password, @remote, @debug)
  XMPPTest.run
}
