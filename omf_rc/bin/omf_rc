#!/usr/bin/env ruby

require "optparse"
require 'omf_common'
require 'omf_rc'
require 'omf_rc/resource_proxy'
$stdout.sync = true

include OmfRc::ResourceProxy

module OmfRc::ResourceProxy
  module Mock
    def test
    end
  end
end

options = {
  dsl: 'xmpp_blather',
  pubsub_host: 'pubsub',
  node: 'interlagos'
}

executable_name = File.basename($PROGRAM_NAME)

option_parser = OptionParser.new do |opts|
  opts.banner = "usage: #{executable_name} [options]"

  opts.on("-u USER", "Username") do |user|
    options[:user] = user
  end

  opts.on("-p PASSWORD", "Password") do |password|
    options[:password] = password
  end

  opts.on("-s SERVER", "XMPP server") do |server|
    options[:server] = server
  end

  opts.on("-d", "--debug", "Debug mode") do
    options[:debug] = true
  end
end

begin
  option_parser.parse!
rescue => e
  puts e.message
  puts ""
  puts option_parser.help
  exit(1)
end

unless options[:server] && options[:user] && options[:server]
  puts option_parser.help
  exit(1)
end

Blather.logger = logger
Blather.logger.level = Logger::DEBUG if options[:debug]

resource_node = AbstractResource.new(type: 'node', uid: options[:node])

comm = OmfCommon::Comm.new(options[:dsl])
host = nil

comm.when_ready do
  logger.info "CONNECTED: #{comm.jid.inspect}"
  host = "#{options[:pubsub_host]}.#{comm.jid.domain}"

  comm.create_node(options[:node], host) do |s|
    comm.subscribe(options[:node], host)
    #comm.publish(options[:node], OmfCommon::Message.configure {|v| v.property('test', rand(100))}.sign, host)
  end
end

# Fired when message published
comm.node_event :items, :node do |e|
  e.items.each do |item|
    m = OmfCommon::Message.parse(item.payload)
    resource_type = m.xpath("//xmlns:property[@key='type']", :xmlns => "http://schema.mytestbed.net/6.0/protocol").map(&:content).join(" ")
    begin
      resource_mock = resource_node.create(type: resource_type)
      if resource_mock && resource_mock.respond_to?(:test)
        logger.info "We created a resource #{resource_mock}, and it is created properly"
        logger.info "We now have #{resource_node.children.size} resources"
      end
    rescue => e
      logger.error e.message
    end
  end
end

# Fired when node created
comm.node_event :items do |e|
  logger.info "NODES: #{e.items.map(&:id)}"
end

# Generic pubsub event
comm.pubsub_event do |e|
  logger.debug "PUBSUB GENERIC EVENT: #{e}"
end

trap(:INT) { comm.disconnect(host) }
trap(:TERM) { comm.disconnect(host) }

EM.run { comm.connect(options[:user], options[:password], options[:server]) }
